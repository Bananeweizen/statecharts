h1(#Gettingstartedtutorial). Getting started

{toc}

h2(#Introduction). Introducing YAKINDU Statechart Tools

This tutorial introduces YAKINDU Statechart Tools (SCT). It provides an integrated modeling environment for the specification and development of reactive, event-driven systems based on the concept of state machines or statecharts. It is an easy-to-use tool featuring sophisticated graphical statechart editing, validation and simulation of statecharts as well as code generation.

This tutorial you will teach how to
* create a new statechart model, 
* execute it using the simulation engine, and
* generate Java source code to get a fully-working statechart implementation.

Please note that this tutorial will not explain statecharts in general, so you should familiarize yourself with the basic concepts of state machines first.[1]

Before we get started, make sure you have YAKINDU Statechart Tools installed. For installation instructions, see the "Installation documentation":../02_installation/installation.html.


h2. The light switch example

The most simple example of a state machine that actually does something is a light switch. In this scenario there is a light bulb and a switch to turn the bulb on and off. Of course there's also a power source and some electrical cabling to put it all together.

h3. The behaviour of a light switch

When modeling the light switch example as a statechart, we can disregard everything (even the bulb) except for the switch. The behaviour of the switch is very simple:
* Initially the light switch is off, i.&nbsp;e. it is in its *Off* state.
* If the light switch is operated while being in its *Off* state, it changes to its *On* state.
* If the light switch is operated while being in its *On* state, it changes to its *Off* state.


h2. Modeling the light switch as a statechart

Now let's model the light switch as a statechart using YAKINDU Statechart Tools. This involves the following steps:
# Creating an Eclipse project. It will serve as a container for the statechart model.
# Modeling the light switch using the YAKINDU Statechart Tools editor. The result will be a static statechart model.
# Simulating the model. We can play around with the model, operate the light switch and observe its behaviour.
# Generate Java source code. The result will be a Java implementation of the state machine that we can integrate with Java client code.

h3. Creating an Eclipse project

The first step is to create a new Eclipse project that can serve as a container for our model. From the main menu, select _File → New → Project…_:

!images/light_switch_010_menu_file_new_project.png!

The _New Project_ wizard opens, showing a couple of different project types structured in various folders.

!images/light_switch_020_wizard_new_project_general_project.png!

If we only wanted to create the statechart model and run the simulator on it, we could select _General → Project_ in the wizard (see above) in order to choose the most basic Eclipse project type.

However, after having created a statechart, users often also want to have an implementation of their state machine in some programming language, so that they can integrate it into their software projects. In such cases it is advisable to create a language-specific Eclipse project right from the start. This will save you from hassles later.

Subsequently we will assume that your programming language is Java and consequently will work with a Java project. Don't worry if you don't have anything to do with Java! We won't dive into programming details! 

In the _New Project_ wizard, select _Java → Java Project_:

!images/light_switch_030_wizard_new_project_java_java_project.png!

Click _Next >_. The wizard changes to the _New Java Project_ page:

!images/light_switch_040_wizard_new_java_project.png!

Specify a meaningful _Project name_, e.&nbsp;g. *LightSwitch*, and optionally select a _Location_ to create the project in.

Click _Finish_.

Since Eclipse has a dedicated perspective for Java projects, it asks you whether you want to change to it now or not:

!images/light_switch_050_dialog_open_associated_perspective.png!

Your answer really doesn't matter too much, because you can switch perspectives at any time. Click _Yes_ to acknowlegde opening the Java perspective. By having checked _Remember my decision_ you can also instruct Eclipse to never ask this question again (regarding the Java perspective).

Eclipse creates the new Java project and establishes a folder _src_ inside of it. The latter is indended for user-created Java source code. Initially it is empty. 

!images/light_switch_060_java_project_created.png!


h3. Creating a folder for the model

Now that we have created the Eclipse project, we can establish the statechart model of the light switch. It is good practice to use a separate directory for models, so let's create a new folder called _model_.

Right-click on the project's root, i.&nbsp;e. on *LightSwitch*, then select _New → Folder_ from the context menu.

!images/light_switch_100_menu_new_folder.png!

The _New Folder_ wizard opens:

!images/light_switch_110_wizard_new_folder.png!

Give the model folder a reasonable name, e.&nbsp;g. *model*, and type it into the _Folder Name_ text field. Then click _Finish_.

The new _model_ folder is created and appears in the package explorer.


h3. Starting with an empty statechart model

h4. Using the YAKINDU Statechart wizard

Now we are going to create an empty statechart model in the _model_ folder. Right-click on the _model_ folder and select _New → Other_ in the context menu:

!images/light_switch_120_menu_new_other.png!

The _New_ wizard opens. Select _Yakindu → Statechart model_

!images/light_switch_130_wizard_new.png!

Click _Next >_. The wizard shows the _New YAKINDU Statechart_ dialog:

!images/light_switch_140_wizard_new_yakindu_statechart.png!

The dialog asks you for the project, the directory, and the name of the model file to be created. Eclipse project and directory should be correctly preset already. In our case the corresponding text field contains *LightSwitch/model* which means the directory named *model* in the *LightSwitch* project. You can change that if you wish, but most likely you won't.

The default file name in the _File Name_ field is *default.sct*, however. You should change that to something more meaningful. In our case we type *LightSwitch.sct* into the _File name_ field, see the screenshot above.

Click _Finish_.

Answer the question regarding switching to the YAKINDU Modeling perspective with _Yes_.

!images/light_switch_150_dialog_confirm_perspective_switch.png!

h4. The initial model

An empty statechart is created and displayed in the large editor compartment in the middle of the Eclipse workbench. This is the *statechart editor*, marked by a red rectangle in the screenshot below. It is used to edit statecharts graphically. Subsequently, we will use it to develop the light switch statechart.

!images/light_switch_220_statechart_editor.png!

Actually the new statechart isn't really empty. It already contains the initial state (a small filled black circle), a "normal" state, and a transition leading from the former to the latter.

h3. Statechart validation

The "normal" state, however, is marked with a small filled red circle containing a white 'X'. This is an error marker and tells you that something is wrong with your model or, more particularly, with the state it is attached to.

The error marker is also shown in the _Project Explorer_ view at the left-hand side of the main window. So you can see immediately which of your projects contain errors. Click on the small show/hide symbol (a triangle) left from a project's or any other resource's name in order to display or hide its respective contents. In this way you will quickly find out which directories and files are affected by errors. In the screenshot above we have clicked open the _LightSwitch_ project and the _model_ directory, showing the error is in the _LightSwitch.sct_ file.

The error marker exemplifies YAKINDU Statechart Tools' model validation capabilities. Statechart validation includes syntactical and semantical checks of the whole statechart. For examples, a statechart is checked for unreachable states, dead ends, or references to unknown events. These validation constraints are checked during editing. In case any constraints are violated, warning or error markers are attached to the faulty model elements. Thus the user receives direct and immediate feedback on the validation state of his statechart.

Hovering with the mouse over the error marker in the statechart editor reveals what the problem is. A small popup appears and displays the error description: "A state must have a name."

!images/light_switch_210_error_marker_and_popup.png!

An alternative place to see error messages is the _Problems_ view at the bottom of the Eclipse window. This view displays:
* The total number of errors, warnings, and others. In our case we have one error and nothing else.
* Lists containing errors, warnings, and others, if available. In our example there is a single list containing error messages. Click on the show/hide symbol to show or hide the message list or just its header. 

Double-clicking on an error message in the _Problems_ view brings you directly to the erroneous object.

Hang on, we will correct the error in a second!


h3. Giving a state a name

As we have seen, the initial statechart is erroneous insofar as the state does not have a name. So let's fix that.

The first requirement demands the switch to be off initially. The erroneous state is reached from the initial state immediately, so it is appropriate to name it *Off*.

Double-click on the string @<name>@ in the state object. The string turns into a text input field with @<name>@ being highlighted:

!images/light_switch_230_statechart_editor_change_state_name_01.png!

Type the state's new name, i.&nbsp;e. @Off@:

!images/light_switch_230_statechart_editor_change_state_name_02.png!

Hit the @[Enter]@ key. Bingo! The state now has a proper name and the error marker disappears:

!images/light_switch_230_statechart_editor_change_state_name_03.png!

However, since the state box's size is smaller now than before while the box's left position remains unchanged, everything looks crooked.

We can improve the graphics by dragging the state box a little bit to the right. When it is centered below the initial state symbol, a vertical blue line appears giving the user a visual hint:

!images/light_switch_230_statechart_editor_change_state_name_04.png!

Drop the state box at this very place, and everything looks better:

!images/light_switch_230_statechart_editor_change_state_name_05.png!

Alternatively, we could have used the state box's handles to resize it. However, we just deselect the box by clicking elsewhere:

!images/light_switch_230_statechart_editor_change_state_name_06.png!


h3. Creating a state

With the *Off* state only the light switch statechart isn't complete yet. We also need an *On* state, and we going to create it now. In order to add another state, move the mouse pointer to the _Palette_ compartment at the right-hand side of the statechart editor. Click on the _State_ symbol in the palette without releasing the mouse button, and drag the symbol over to the editing area.

!images/light_switch_240_statechart_editor_create_state_01.png!

Release the mouse button over a gray area, a region:

!images/light_switch_240_statechart_editor_create_state_02.png!

The new state appears in the model graph:

!images/light_switch_240_statechart_editor_create_state_03.png!

Rename the new state to *On*. Vertically align it to the *Off* state, if you like:

!images/light_switch_240_statechart_editor_create_state_04.png!

You'll notice that the new state is showing an error marker. The reason is that it is not yet possible to reach the *On* state.

Before we'll go on and fix that problem, here's another way to create a new state. When you are hovering with the mouse pointer over the main region, i.&nbsp;e. the rectangle with a gray background, a popup menu shows up. If you click on the 'S' symbol in that menu, a new state will be created. Other options in this menu are to create an initial state, a final state, or a choice.

!images/light_switch_240_statechart_editor_create_state_05.png!

h3. Creating a transition

As we have seen above, the *On* state is not reachable as of yet. So let's model switching the light switch from "off" to "on" as a transition leading from the *Off* state to the *On* state.

In the _Palette_, click on the _Transition_ symbol. The symbol's background turn blue.

!images/light_switch_250_statechart_editor_create_transition_01.png!

Click on the *On* state, but don't release the mouse button. Drag the mouse pointer towards the *Off* state. A light gray line is shown as a preview of the transition to be established:

!images/light_switch_250_statechart_editor_create_transition_02.png!

Once the mouse pointer reaches the target state, it changes its shape:

!images/light_switch_250_statechart_editor_create_transition_03.png!

Releasing the mouse button establishes the transition. A text input field to specify event trigger, guard condition and effect appears. We want the transition to be triggered when the light switch is operated, so let's type @operate@ into the text field.

!images/light_switch_250_statechart_editor_create_transition_04.png!

If you suspect that something is not in order, because the input text is underlined in red, you are right. We will explain and deal with that in a minute.

Clicking anywhere outside the text field terminates the editing mode:

!images/light_switch_250_statechart_editor_create_transition_05.png!

The event trigger _operate_ is flagged as an error. The reason is that an event with that name is not known yet. The screenshot below shows how to change that: 

!images/light_switch_260_statechart_editor_create_definitions_01.png!

Double-click into the *definition section* on the left-hand side of the statechart editor. The section becomes an editable text field.

Enter the following text:

bc(prettyprint). 
internal:
	event operate

Click anywhere outside of the text field, which terminates editing the definition section. The statechart editor digests the definition, recognizes the definition of the _operate_ event, and validates the model as being okay:

!images/light_switch_260_statechart_editor_create_definitions_02.png!

In its current state the model would not allow to turn the light switch off again, which is somewhat unsatisfactory. However, operating the light switch while it is on should turn it off. Let's model this by adding another transition. It should lead from the source state *On* to the target state *Off*.

However, in order to not get two straight lines being close together in the graph, let's first make some room and turn the present line into an arc. Move the mouse pointer over the transition line, but not over the text. The mouse pointer changes its shape to indicate that you can insert a control point. Click and hold to add the control point, then drag it to an appropriate position.

!images/light_switch_270_statechart_editor_create_transition_01.png!

Now let's insert the second transition. This time we won't use the palette, but instead use another method. Hover the mouse pointer over the source state, i.&nbsp;e. *On*. An ingoing and an outgoing arrow appear, both with a handle.  Click and hold the handle of the outgoing arrow and drag it to the *Off* target state.

!images/light_switch_270_statechart_editor_create_transition_02.png!

Upon releasing the mouse button the transition is established. Type @operate@ as the transition's event trigger into the text field. Reshape the transition arrow to make the graph look nice.

!images/light_switch_270_statechart_editor_create_transition_03.png!



h2. Simulating the light switch model

Simulating a model means to execute it, raise events manually, have timed and run cycle-based events being triggered automatically, and observe its behaviour.

Start the simulation by right-clicking on the _LightSwitch.sct_ file in the project explorer and selecting _Run As → Statechart Simulation_:

!images/light_switch_300_statechart_simulator_run_as_statechart_simulation.png!

The perspective changes from _SC Modeling_ to _SC Simulation_. This perspective defines two additional views:
* The _Debug_ view at the top shows all running statechart instances and allows to select one of them. YAKINDU Statechart Tools allow multiple executions of the same statechart as well as parallel executions of different statecharts at the same time.
* The _Simulation_ view on the right-hand side is used to raise events and to inspect and modify variables.

Not surprisingly, the simulation starts at the initial state and then transitions to the *Off* state immediately. The latter becomes the active state now. It is highlighted by a red background:

!images/light_switch_310_statechart_simulator_state_off.png!

Now that the light switch is off, let's turn the lights on by operating the switch. In the simulation, we will have to raise the _operate_ event. How can we do this?

In the _Simulation_ view at the right-hand side of the Eclipse workbench, click on the _internal_ entry's show/hide symbol to display its contents.

!images/light_switch_320_statechart_simulator_state_events.png!

The _operate_ event is shown. Click on it to raise the event, i.&nbsp;e. to operate the light switch. 

The transition arc leading from the *Off* state to the *On* state flashes briefly in red, and the *On* state becomes active. Its background color changes to red while the *On* state's background color becomes normal again. 

!images/light_switch_330_statechart_simulator_state_on.png!

Click on _operate_ again, and the active state changes back to *Off*. Click on _operate_ several times and enjoy watching the state machine's behaviour.

Stop the simulator by clicking at the little red termination button in the toolbar at the top.



h2. CallHandling example explained

p(#Prepareaproject). During this tutorial we will create a system for handling incoming phone calls as a sample application. After startup, the system is in an idle state and is waiting for incoming calls. When a call comes in, the user can either accept the call or dismiss it. If the users accepts the call and opens a connection, the system is tracking the duration of the call and is waiting for the user to hang up. After hanging up, the system displays the total time of call and then returns to its idle state. The complete statechart model is shown below:

!(img-rounded shadowed)images/example.png!

h2. Preparing a project

p(#Createastatechartmodel). The first step is to create a new Eclipse project by selecting _File → New → Project…_. A wizard opens, showing a couple of different project types. Since we want to generate Java code from our statechart model later on, select _Java → Java Project_ from the wizard menu. Give the project a meaningful name, e.g. *CallHandling* and click _Finish_.

!images/callhandling_010_create_java_project.png

As a result, Eclipse creates the project and establishes a folder _src_ inside of it. Initially this folder is empty. It is indended for user-created Java code.

!images/callhandling_020_new_java_project.png!

However, we won't deal with Java programming right now, but rather create our statechart model first. It is good practice to keep models and source code separate. So, let's create a new folder for the model. Right-click on the project's root, i.&nbsp;e. on *CallHandling*, then select _New → Folder_ from the context menu. Give the model folder a reasonable name by typing e.&nbsp;g. *model* into the _Folder Name_ text field, then click _Finish_. The new _model_ folder appears in the package explorer:

!images/callhandling_030_model_folder_created.png!

h2. Creating a statechart model

p(#UsetheEditor). Next, create the statechart model itself:
* Right-click the *model* folder. The context menu opens.
* Select _New → Other_. The _New_ wizard opens.
* In the _New_ wizard, select _YAKINDU SCT → Statechart model_.<br/>!images/callhandling_040_create_model_new_statechart_model.png!
* Click _Next_.
* In the following dialog, the wizard asks for the name the of the model file and for the directory it should be created in. Let's choose *CallHandling.sct* as the file name and *CallHandling/model* as the directory name, i.e. the directory *model* inside the Eclipse project *CallHandling*.<br/>!images/callhandling_050_create_model_specify_name.png!
* Click _Finish_.
* Answer the question regarding the perspective switch with _Yes_.<br/>!images/callhandling_060_create_model_modeling_perspective_dialog.png!
* The statechart editor opens and shows the definition of a very simple statechart. You will notice that the statechart editor flags an error in the model. This is due to the fact that the state does not have a name yet. The error marker will disappear once when have named the state.<br/>!images/callhandling_070_create_model_completed.png!<br/>

h2. Using the editor

Within the Eclipse workbench, the area marked by a red rectangle in the image below is the *statechart editor*. The subsequent paragraph will explain how to work with it, how to create and modify the statechart for the _CallHandling_ example.

!images/callhandling_080_editing_editor.png!

h3. Creating interfaces

Statecharts can describe very complex interactions between a multitude of actors and an even bigger multitude of events these actors can receive or trigger. It is therefore good practice to structure those events and associate them with their respective actors. For this purpose YAKINDU Statecharts Tools provides the concept of so-called *interfaces*.

In the _CallHandling_ example, we have two actors: the user and the phone. Let's model their communication as two interfaces:
* The _Phone_ interface provides a single incoming event named _incoming_call_.
* The _User_ interface comprises two incoming events: _accept_call_ and _dismiss_call_.

We have to enter the respective definitions in textual form into the statechart editor. Here's how the interface definitions look like:

bc(prettyprint). interface User:
    in event accept_call
    in event dismiss_call

bc(prettyprint). interface Phone:
    var duration : integer
    in event incoming_call

As you can see, _Phone_ interface also has an integer variable _duration_, which will be explained later. This text has to go into the statechart editor's *definition block*, which is the compartment on the statechart editor's left-hand side. To enter the text, double-click on the definition block and start typing.

Hint: The text editor offers context-sensitive assistance helping you to know what keyword etc. are allowed at the very position the text cursor currently is. Let's assume you have just entered the definition of the _User_ interface and your text cursor is positioned _behind_ that definition.
# Press @[Ctrl+Space]@. This key combination invokes the *content assist*. A popup window appears showing all keyword alternatives that are allowed here.
# Single-click on one of the alternatives, say on @interface@, and a help text containing a detailed description with sample code is displayed in a second popup window.
# Double-click on it, and the keyword is carried over into the text field.

!images/callhandling_090_editing_interfaces.png!

h3. Creating states

Next, rename the initially created state to *Idle* by double-clicking on the name label and entering the new name. The error marker will disappear.

Statechart validation includes syntactical and semantical checks of the whole statechart. For examples, a statechart is checked for unreachable states, dead ends, or references to unknown events. These validation constraints are checked during editing. In case any constraints are violated, warning or error markers will be shown, attached to the faulty model elements. Thus the user receives direct and immediate feedback on the validation state of his statecharts.

Now, create the three states *Incoming Call*, *Active Call* and *Dismiss Call* by dragging _States_ symbol from the palette on the right onto the main region thrice and naming the states appropriately.

h3. Creating transitions

Connect the states using the _Transition_ tool from the palette as shown in the sample model above. After creating a transition, select the appropriate event (use the content assist @[Ctrl+Space]@ to navigate from interfaces to events) in the direct editing pop-up.

Finally, create the *Active Call* and *Dismiss Call* states' internal behavior. This can either be done by opening the direct editing text box via double-clicking or by using the property view at the bottom. The text box supports code completion, syntax highlighting and validation.

If everything went well, the error markers should be gone. Your model should look like the one in the following screenshot:

!(img-rounded shadowed)images/example_final.png!

p(#Simulatingthemodel). If something went wrong and you cannot eliminate the problem, you can download the sample project "here":examples/CallHandling.zip.

h2. Simulating the model

To start the dynamic simulation of your model, right-click on the model file *CallHandling.sct* in the Eclipse _Project Explorer_, then select _Run As → Statechart Simulation_ in the context menu.

The perspective changes from _SC Modeling_ to _SC Simulation_. The simulation perspective defines two additional views: The _Debug_ view at the top shows all running statechart instances and allows to select one of them. Please note that SCT allows multiple executions of the same statechart as well as parallel executions of different statecharts at the same time.7

You can use the _Simulation_ view on the right to raise events and to inspect and modify variables.

When the simulation starts, the *Idle* state becomes active since it is connected to the *Initial State*. An active state is visualized by a red background color in the statechart view.

Now let's simulate an incoming call. Raise the associated event by clicking at the _incoming_call_ text formatted as a hyperling in the _Simulation_ view on the right. This event will trigger a state transition from *Idle* to *Incoming Call*. Accept the call by raising the _accept_call_ event. Another transition happens, and the state *Active Call* becomes active. For the duration of the call, the variable _duration_ in the _Simulation_ view is incremented every second. When you are done with your phone call, raise the _dismiss_call_ event. The state machine transitions to the *Dismiss Call* state, and two seconds later returns to its *Idle* state.

If your statechart behaves as expected, we can go one step further now and generate code from it. Before doing so, stop the simulator by clicking at the little red terminate button in the toolbar at the top.


h2(#Footnotes). Footnotes

fn1. "UML state machine":http://en.wikipedia.org/wiki/UML_state_machine

fn2. Not to be confused with user interfaces.
