module org.yakindu.sct.generator.genmodel.GenerateSGen

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.generator.*
import org.eclipse.xtext.ui.generator.*

var grammarURI = "classpath:/org/yakindu/sct/generator/genmodel/SGen.xtext"
var file.extensions = "sgen"
var projectName = "org.yakindu.sct.generator.genmodel"
var runtimeProject = "../${projectName}"

Workflow {
    bean = StandaloneSetup {
        scanClassPath = true
        platformUri = "${runtimeProject}/.."
		registerGenModelFile = "platform:/resource/org.yakindu.sct.model.sgen/model/emf/sgen.genmodel"
    }

    component = DirectoryCleaner {
        directory = "${runtimeProject}/src-gen"
    }

    component = DirectoryCleaner {
        directory = "${runtimeProject}.ui/src-gen"
    }

    component = Generator {
        pathRtProject = runtimeProject
        pathUiProject = "${runtimeProject}.ui"
//        pathTestProject = "../../test-plugins/${projectName}.test"
        projectNameRt = projectName
        projectNameUi = "${projectName}.ui"
        language = {
            uri = grammarURI
            fileExtensions = file.extensions

            // Java API to access grammar elements (required by several other fragments)
			fragment = grammarAccess.GrammarAccessFragment auto-inject {}

            // generates Java API for the generated EPackages
            fragment = ecore.EMFGeneratorFragment auto-inject  {
            	emfRuntimeVersion = "2.8"
            }

           // serializer 2.0
    		fragment = serializer.SerializerFragment auto-inject {
    			generateStub = false
    		}
            
            // a custom ResourceFactory for use with EMF
    		fragment = resourceFactory.ResourceFactoryFragment auto-inject {}

            // The antlr parser generator fragment.
    		fragment = parser.antlr.XtextAntlrGeneratorFragment auto-inject {}

            // java-based API for validation
            fragment = validation.JavaValidatorFragment auto-inject {
                composedCheck = "org.eclipse.xtext.validation.ImportUriValidator"
                composedCheck = "org.eclipse.xtext.validation.NamesAreUniqueValidator"
            }

            // scoping and exporting API
    		fragment = scoping.ImportNamespacesScopingFragment auto-inject {}
    		fragment = exporting.QualifiedNamesFragment auto-inject {}
    		fragment = builder.BuilderIntegrationFragment auto-inject {}

            // formatter API 
			fragment = formatting.FormatterFragment auto-inject {}

			// labeling API 
			fragment = labeling.LabelProviderFragment auto-inject {}

			// outline API 
			fragment = outline.OutlineTreeProviderFragment auto-inject {}

			// quickfix API 
			fragment = quickfix.QuickfixProviderFragment auto-inject {}

			// content assist API
    		fragment = contentAssist.ContentAssistFragment auto-inject {}
			
            // generates a more lightweight Antlr parser and lexer tailored for content assist
    		fragment = parser.antlr.XtextAntlrUiGeneratorFragment auto-inject {}

            // generates junit test support classes into Generator#pathTestProject
            fragment = junit.Junit4Fragment auto-inject {}

            // provides a preference page for template proposals
            fragment = templates.CodetemplatesGeneratorFragment auto-inject {}

            // rename refactoring
            fragment = refactoring.RefactorElementNameFragment auto-inject {}

            // provides a compare view
            fragment = compare.CompareFragment {
                 fileExtensions = file.extensions
            }

        }
    }
}
